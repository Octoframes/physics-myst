{"kind":"Notebook","sha256":"e58a4ea11ab1ac8078147ef8ed3f7585562f98ce1d389c4e05a12eb885b70629","slug":"pendulum","dependencies":[],"frontmatter":{"authors":[],"github":"https://github.com/Octoframes/physicsmyst","keywords":[],"exports":[{"format":"ipynb","filename":"pendulum.ipynb","url":"/physicsmyst/build/pendulum-e3767c1f8a58d7b85bed375eead39538.ipynb"}]},"mdast":{"type":"root","children":[{"type":"block","position":{"start":{"line":0,"column":0},"end":{"line":1,"column":0}},"children":[{"type":"code","lang":"python","executable":true,"value":"from typing import DefaultDict\nfrom manim import *\nimport subprocess, sys\nimport numpy as np\nimport math\n\nconfig.media_embed = True\n\nfrom collections import defaultdict\n\n#############################################\n# Generalized N pendulum\n#############################################\nclass Pendulum:\n    def __init__(self, N, theta=None):\n        self.N = N;\n        self.gravity = 9.81\n        self.L = np.ones(shape=(N, )) # lengths\n        self.m = np.ones(shape=(N, )) # masses\n        \n        self.theta = np.zeros(shape=(N, )) if theta is None else theta\n        self.theta_dot = np.zeros(shape=(N, ))\n\n    def step(self, delta_t):\n        equations = np.zeros(shape=(4 * self.N, 4 * self.N + 1))\n        theta_dd = 0\n        a_xn = theta_dd + self.N\n        a_yn = a_xn + self.N\n        T_n = a_yn + self.N\n        for p in range(0, 4 * self.N, 4):\n            n = p // 4\n            # First equation x_dd\n            equations[p, theta_dd + n] = self.L[n] * math.cos(self.theta[n])\n            equations[p, a_xn + n] = -1.0;\n            if n > 0:\n                equations[p, a_xn + n - 1] = 1\n            equations[p, -1] = self.theta_dot[n]**2 * math.sin(self.theta[n])\n\n            # Second equation y_dd\n            equations[p + 1, theta_dd + n] = -1.0 * self.L[n] * math.sin(self.theta[n])\n            equations[p + 1, a_yn + n] = -1.0\n            if n > 0:\n                equations[p + 1, a_yn + n - 1] = 1.0\n            equations[p + 1, -1] = self.theta_dot[n]**2 * math.cos(self.theta[n])\n\n            # Third equation horizontal tension\n            equations[p + 2, a_xn + n] = self.m[n]\n            equations[p + 2, T_n + n] = math.sin(self.theta[n])\n            if n + 1 < self.N:\n                equations[p + 2, T_n + n + 1] = -1.0 * math.sin(self.theta[n + 1])\n            equations[p + 2, -1] = 0\n\n            # Fourth equation vertical tension\n            equations[p + 3, a_yn + n] = self.m[n]\n            equations[p + 3, T_n + n] = math.cos(self.theta[n])\n            if n + 1 < self.N:\n                equations[p + 3, T_n + n + 1] = -1.0 * math.cos(self.theta[n + 1])\n            equations[p + 3, -1] = self.m[n] * self.gravity\n\n        solution = np.linalg.solve(equations[:, 0:-1], equations[:, -1])\n        self.theta_dot += delta_t * solution[0:self.N]\n        self.theta += delta_t * self.theta_dot\n\n\nclass PhysicalNPendulum(Scene):\n    def construct(self):\n        p = Pendulum(N=2, theta=[math.pi / 2] * 2)\n        scale = 2\n        x_c, y_c = 0, 3\n\n        def get_pendulum(dot_radius=DEFAULT_DOT_RADIUS):\n            points = [[x_c, y_c, 0]] + [[scale * p.L[n] * math.sin(p.theta[n]), -scale * p.L[n] * math.cos(p.theta[n]), 0] for n in range(p.N)]\n            for i in range(1, len(points)):\n                for k in range(3):\n                    points[i][k] += points[i - 1][k]\n            return [ Line(points[i - 1], points[i]) for i in range(1, len(points)) ] + [ Dot(point, radius=dot_radius) for point in points]\n\n        def step(pendulum, dt):\n            for obj in pendulum:\n                pendulum.remove(obj)\n            p.step(dt / 2)\n            for obj in get_pendulum(dot_radius=0.06):\n                pendulum.add(obj)\n\n        pendulum = VGroup()\n        for obj in get_pendulum():\n            pendulum.add(obj)\n        pendulum.add_updater(step)\n        self.add(pendulum)\n        self.wait(5)\n        pendulum.remove_updater(step)\n\n\nparam= \"-v WARNING  --progress_bar None   -r  500,200 --fps=3 --disable_caching PhysicalNPendulum\"\nparamgif= \"-v WARNING  --progress_bar None --format=gif  -r  500,200  --disable_caching PhysicalNPendulum\"\n%manim $param","identifier":"nb-cell-0-05330fc8bf-code","enumerator":"1","html_id":"nb-cell-0-05330fc8bf-code","key":"SpLbpRTCfO"},{"type":"output","id":"hSQKdrN1s6A4nB5v8bP-A","data":[{"output_type":"display_data","metadata":{},"data":{"text/html":{"content":"<pre style=\"white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace\">Manim Community <span style=\"color: #008000; text-decoration-color: #008000\">v0.17.2</span>\n\n</pre>\n","content_type":"text/html"},"text/plain":{"content":"Manim Community \u001b[32mv0.\u001b[0m\u001b[32m17.2\u001b[0m\n\n","content_type":"text/plain"}}},{"output_type":"display_data","metadata":{},"data":{"text/html":{"content":"<video controls autoplay loop style=\"max-width: 60%;\"  >\n <source src=\"data:video/mp4;base64,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\" type=\"video/mp4\">\n Your browser does not support the video tag.\n </video>","content_type":"text/html"},"text/plain":{"content":"<IPython.core.display.Video object>","content_type":"text/plain"}}}],"identifier":"nb-cell-0-05330fc8bf-output","html_id":"nb-cell-0-05330fc8bf-output","key":"MRdGEPo0He"}],"data":{"id":"nb-cell-0-05330fc8bf","type":"notebook-code"},"identifier":"nb-cell-0-05330fc8bf","label":"nb-cell-0-05330fc8bf","html_id":"nb-cell-0-05330fc8bf","key":"d55jwLbfWR"},{"type":"block","position":{"start":{"line":105,"column":0},"end":{"line":106,"column":0}},"children":[{"type":"code","lang":"python","executable":true,"value":"################################################\n# Optimized collection of 2-Pendulum's\n################################################\nclass DoublePendulum():\n    \"\"\" Creates a collection of 2-Pendulums\n        Parameters:\n        theta: np.ndarray with shape (N, 2)\n        lengths (optional): np.ndarray with shape (N, 2) default is all ones\n        masses  (optional): np.ndarray with shape (N, 2) default is all ones\n    \"\"\"\n    def __init__(self, theta, lengths=None, masses=None):\n        self.t = theta\n        self.t_d = np.zeros(theta.shape)\n        self.l = np.ones(theta.shape) if lengths is None else lengths\n        self.m = np.ones(theta.shape) if masses is None else masses\n        self.g = 9.81 # gravity\n\n    def step(self, delta_t, step_size=0.0005):\n        for i in range(math.ceil(delta_t / step_size)):\n            self.smol_step(step_size)\n\n    def smol_step(self, delta_t):\n        m_1, m_2 = self.m[:, 0], self.m[:, 1]\n        t_1, t_2 = self.t[:, 0], self.t[:, 1]\n        l_1, l_2 = self.l[:, 0], self.l[:, 1]\n        t_d1, t_d2 = self.t_d[:, 0], self.t_d[:, 1]\n        bottom = (2 * m_1) + m_2 - (m_2 * np.cos(2 * (t_1 - t_2)))\n        theta_dd1 = (-self.g * (2 * m_1 + m_2) * np.sin(t_1) - m_2 * self.g * np.sin(t_1 - 2 * t_2) - 2 * np.sin(t_1 - t_2) * m_2 * (t_d2**2 * l_2 + t_d1**2 * l_1 * np.cos(t_1 - t_2))) / (l_1 * bottom)\n        theta_dd2 = (2 * np.sin(t_1 - t_2) * (t_d1**2 * l_1 * (m_1 + m_2) + self.g * (m_1 + m_2) * np.cos(t_1) + t_d2**2 * l_2 * m_2 * np.cos(t_1 - t_2))) / (l_2 * bottom)\n        self.t_d[:, 0] += delta_t * theta_dd1\n        self.t_d[:, 1] += delta_t * theta_dd2\n        self.t += delta_t * self.t_d\n\n    def get_nth_pendulum(self, n):\n        return self.t[n, 0], self.t[n, 1]\n\n\nclass Physical2Pendulum(Scene):\n    def construct(self):\n        ps = [0, 3, 0]\n        scale = 2.5\n        angles = True\n        history = defaultdict(lambda: [])\n        theta_hist = defaultdict(lambda: [])\n        theta1 = MathTex(r\"\\theta_1\")\n        theta2 = MathTex(r\"\\theta_2\")\n\n        def mod_clamp(x, low=-math.pi, high=math.pi):\n            return ((x-((high-low)/2)) % (high-low)) + low\n        \n        def lin_scale(x, start, end):\n            return (x - start) / (end - start)\n\n        def get_between(start, end, proportion):\n            return start + (end - start) * proportion\n\n        def get_pendulum(p, pid, tracers=False, color=BLUE, dot_radius=DEFAULT_DOT_RADIUS):\n            t_1, t_2 = p.get_nth_pendulum(0)\n            p0 = [ps[0] + scale * math.sin(t_1), ps[1] - scale * math.cos(t_1), 0]\n            p1 = [p0[0] + scale * math.sin(t_2), p0[1] - scale * math.cos(t_2), 0]\n            x0, x1 = DashedLine([ps[0], ps[1], 0], [ps[0], ps[1] - 1, 0]), DashedLine([p0[0], p0[1], 0], [p0[0], p0[1] - 1, 0])\n            l0, l1 = Line(ps, p0), Line(p0, p1)\n            x0.set_color(color)\n            x1.set_color(color)\n            l0.set_color(color)\n            l1.set_color(color)\n\n            theta_hist[pid].append(np.array([lin_scale(mod_clamp(t_1), -math.pi, math.pi), lin_scale(mod_clamp(t_2), -math.pi, math.pi), 0]))\n            history[pid].append(p1)\n            if len(history[pid]) > 10:\n                history[pid] = history[pid][1:]\n\n            res = [ l0, l1, Dot(ps, radius=dot_radius, color=WHITE), Dot(p0, radius=dot_radius, color=color), Dot(p1, radius=dot_radius, color=color)]\n            if angles:\n                flip0, flip1 = p0[0] < ps[0], p1[0] < p0[0]\n                res += [ x0, x1, Angle(x0, l0, other_angle=flip0), Angle(x1, l1, other_angle=flip1),\n                    MathTex(r\"\\theta_1\").move_to(Angle(x0, l0, other_angle=flip0, radius=0.4 + 3 * SMALL_BUFF).point_from_proportion(0.5)),\n                    MathTex(r\"\\theta_2\").move_to(Angle(x1, l1, other_angle=flip1, radius=0.4 + 3 * SMALL_BUFF).point_from_proportion(0.5))]\n            if tracers:\n                res += [ Line(history[pid][i-1], history[pid][i], color=color) for i in range(1, len(history[pid])) ]\n            return res\n\n\n        def create_pendulum(theta, pid=0, color=BLUE, rate=1, add_updater=True, tracers=True):\n            p = DoublePendulum(theta)\n            pendulum = VGroup()\n            history[pid].clear()\n            for obj in get_pendulum(p, pid, color=color, dot_radius=0.06):\n                pendulum.add(obj)\n\n            def step(pendulum, dt):\n                clear(pendulum)\n                p.step(dt * rate)\n                for obj in get_pendulum(p, pid, color=color, tracers=tracers, dot_radius=0.06):\n                    pendulum.add(obj)\n\n            if add_updater:\n                pendulum.add_updater(step)\n            return p, pendulum, step\n\n        def clear(*objs):\n            for obj in objs:\n                for o in obj:\n                    obj.remove(o)\n\n        def create_pendulum_path(pid, color, s, e):\n            path = VGroup()\n\n            def update(pth, dt):\n                clear(pth)\n                for obj in get_plot_line(pid, s, e, color):\n                    pth.add(obj)\n            path.add_updater(update)\n            return path, update\n\n        def get_plot_line(pid, domain_start, domain_end, color):\n            res = []\n            for i in range(1, len(theta_hist[pid])):\n                p0 = domain_start + theta_hist[pid][i - 1] * (domain_end - domain_start)\n                p1 = domain_start + theta_hist[pid][i] * (domain_end - domain_start)\n                if np.linalg.norm(p1 - p0) <= 4:\n                    res.append(Line(p0, p1, color=color))\n            return res\n\n        def get_color(theta, phi, radius=127, normalize=False):\n            return [(127 + radius * math.cos(phi) * math.sin(theta)) / 255, \n                (127 + radius * math.sin(phi) * math.sin(theta)) / 255,\n                (127 + radius * math.cos(theta)) / 255] if normalize else \\\n            [math.floor(127 + radius * math.cos(phi) * math.sin(theta)), \n                math.floor(127 + radius * math.sin(phi) * math.sin(theta)),\n                math.floor(127 + radius * math.cos(theta))]\n\n        def get_coloring(grid_size):\n            data = [[get_color(get_between(-math.pi, math.pi, i / (grid_size - 1)), get_between(math.pi, -math.pi, j / (grid_size - 1))) for i in range(grid_size)] for j in range(grid_size)]\n            return ImageMobject(np.uint8(data))\n\n        def update_color(object, pid, add_updater=True):\n            def update(obj, dt):\n                if len(theta_hist[pid]) >= 1:\n                    obj.set_fill(rgb_to_color(get_color(get_between(-math.pi, math.pi, theta_hist[pid][-1][0]), get_between(-math.pi, math.pi, theta_hist[pid][-1][1]), normalize=True)))\n            if add_updater:\n                object.add_updater(update)\n            return update\n        \n        def update_circle_pos(obj, pid, s, e, add_updater=True):\n            def update(my_obj, dt):\n                if len(theta_hist[pid]) >= 1:\n                    my_obj.move_to(s + theta_hist[pid][-1] * (e - s))\n            if add_updater:\n                obj.add_updater(update)\n            return update\n\n\n        text1 = Tex(\"This is a double pendulum.\").move_to([0, -3, 0])\n        text2 = Tex(\"Its behavior is chaotic.\").move_to([0, -3, 0])\n        text3 = Tex(r\"This means that small changes to the initial conditions \\\\ result in wildly different behaviors.\").move_to([0, -3, 0])\n        text4 = Tex(\"Let's see this happen.\").move_to([0, -3, 0])\n        text5 = Tex(r\"Let's do this again, but plot \\\\ how the angles of each \\\\ pendulum change over time.\").to_corner(LEFT * 0.5 + DOWN)\n        text6 = Tex(r\"Let's assign a unique color to each point on our plot.\").move_to([0, -3.5, 0])\n        text7 = Tex(r\"The pendulum's state $(\\theta_1, \\theta_2)$ can be mapped to a color\").move_to([0, -3.5, 0])\n\n        p, pendulum, s = create_pendulum(np.ones((1, 2)) * math.pi / 2.0, BLUE, add_updater=False)\n        self.add(pendulum)\n        self.play( Create(pendulum) )\n        self.play( Create(text1) )\n        pendulum.add_updater(s)\n        self.wait(4)\n\n        clear(pendulum)\n        self.play( Transform(text1, text2) )\n        self.wait(5)\n\n        clear(pendulum)\n        self.play( Transform(text1, text3) )\n        self.wait(6)\n        pendulum.remove_updater(s)\n        self.play(FadeOut(pendulum))\n        self.remove(pendulum)\n\n        #######################################################################\n        angles = False\n        p1, pendulum1, s1 = create_pendulum(np.ones((1, 2)) * math.pi / 2.0, pid=1, color=BLUE, add_updater=False)\n        p2, pendulum2, s2 = create_pendulum(np.ones((1, 2)) * math.pi / 1.9, pid=2, color=ORANGE, add_updater=False)\n        self.add(pendulum1, pendulum2)\n        self.play( Create(pendulum1), Create(pendulum2), Transform(text1, text4) )\n        pendulum1.add_updater(s1)\n        pendulum2.add_updater(s2)\n        self.wait(15)\n        pendulum1.remove_updater(s1)\n        pendulum2.remove_updater(s2)\n        self.play(FadeOut(pendulum1), FadeOut(pendulum2))\n        self.remove(pendulum1, pendulum2)\n\n        #######################################################################\n        plot = Square(side_length=6.5).to_corner(RIGHT + UP)\n        t1, t2 = MathTex(r\"\\theta_1\").shift(3.3611 * RIGHT + 3.5 * DOWN), MathTex(r\"\\theta_2\").move_to([-0.3, 0.25, 0])\n        p_pi1, m_pi1 = MathTex(r\"\\pi\").move_to([-0.2, 3.5, 0]), MathTex(r\"-\\pi\").move_to([0.1111, -3.25, 0])\n        p_pi2 = MathTex(r\"\\pi\").move_to([6.61111, -3.25, 0])\n        self.add(plot, t1, t2)\n        self.play( Transform(text1, text5), Create(plot),\n            Create(t1), Create(t2),\n            Create(p_pi1), Create(m_pi1),\n            Create(p_pi2)\n        )\n\n        p_start = np.array([0.11111, -3, 0])\n        p_end = np.array([6.6111, 3.5, 0])\n        ps = [-3.5, 3, 0]\n        scale = 1.7\n        p1, pendulum1, s1 = create_pendulum(np.ones((1, 2)) * math.pi / 2.0, pid=3, color=BLUE, add_updater=False)\n        p2, pendulum2, s2 = create_pendulum(np.ones((1, 2)) * math.pi / 1.9, pid=4, color=ORANGE, add_updater=False)\n        path1, p_s1 = create_pendulum_path(3, BLUE, p_start, p_end)\n        path2, p_s2 = create_pendulum_path(4, ORANGE, p_start, p_end)\n        self.add(pendulum1, pendulum2, path1, path2)\n        self.play( Create(pendulum1) )\n        self.wait(1)\n        pendulum1.add_updater(s1)\n        pendulum2.add_updater(s2)\n        self.wait(18)\n        pendulum1.remove_updater(s1)\n        pendulum2.remove_updater(s2)\n        path1.remove_updater(p_s1)\n        path2.remove_updater(p_s2)\n        self.play(FadeOut(pendulum1), FadeOut(pendulum2), FadeOut(path1), FadeOut(path2))\n        self.play(Transform(text1, text6), FadeOut(p_pi1), FadeOut(p_pi2), FadeOut(m_pi1), FadeOut(t1), FadeOut(t2))\n        self.remove(pendulum1, pendulum2, path1, path2)\n        \n        #######################################################################\n        angles = True\n        grid_size = 878\n        ps = [-3.5, 3, 0]\n        scale = 1.7\n        p, pendulum, s = create_pendulum(np.ones((1, 2)) * math.pi / 2.0, pid=5, color=BLUE, add_updater=False, tracers=False)\n        coloring = get_coloring(grid_size).scale(270 / grid_size * 6.45 / 2).to_corner(LEFT + UP)\n        text_mapping = MathTex(r\"(\\theta_1, \\theta_2) \\to \").to_corner(LEFT * 2 + DOWN * 2)\n        square_fill = Square(0.5, fill_opacity=1).move_to([-3.5, -2.75, 0])\n        square_fill.set_fill(rgb_to_color(get_color(math.pi / 2, math.pi / 2, normalize=True)))\n        lens = Circle(radius=0.3, fill_opacity=1, color=WHITE).move_to(p_start + (p_end - p_start) * np.array([lin_scale(mod_clamp(math.pi / 2), -math.pi, math.pi), lin_scale(mod_clamp(math.pi / 2), -math.pi, math.pi), 0]))\n        lens.set_fill(rgb_to_color(get_color(math.pi / 2, math.pi / 2, normalize=True)))\n        self.wait(1)\n        self.add(coloring)\n        self.play( coloring.animate.move_to([0.11111 + 6.5 / 2, -3 + 6.5 / 2, 0]))\n        self.wait(3)\n        self.add(pendulum)\n        self.play( Create(pendulum), Transform(text1, text7))\n        self.wait(2)\n        self.play( Create(text_mapping), Create(square_fill), Create(lens) )\n        self.wait(2)\n        sf_u = update_color(square_fill, 5, add_updater=True)\n        l_u = update_color(lens, 5, add_updater=True)\n        l_u2 = update_circle_pos(lens, 5, p_start, p_end, add_updater=True)\n        pendulum.add_updater(s)\n        self.wait(20)\n        pendulum.remove_updater(s)\n        lens.remove_updater(l_u)\n        lens.remove_updater(l_u2)\n        square_fill.remove_updater(sf_u)\n        self.play( FadeOut(lens), FadeOut(square_fill), FadeOut(pendulum), FadeOut(coloring), FadeOut(text_mapping), FadeOut(text1), FadeOut(plot))\n        self.remove(lens, square_fill, pendulum, coloring, text_mapping, text1, plot)\n        self.wait(1)\n\n\n\nclass FractalPlot(Scene):\n    def construct(self):\n        grid_size = 945\n        angle_domain = [-math.pi, math.pi]\n        angle_from_proportion = lambda x: (angle_domain[1] - angle_domain[0]) * x + angle_domain[0]\n        theta = np.ones((grid_size**2, 2))\n        for i in range(grid_size**2):\n            x, y = i % grid_size, i // grid_size\n            theta[i, 0] = angle_from_proportion(x / grid_size)\n            theta[i, 1] = angle_from_proportion(y / grid_size)\n        p = DoublePendulum(theta)\n\n        def get_color(theta, phi, radius=127):\n            return [math.floor(127 + radius * math.cos(phi) * math.sin(theta)), \n                math.floor(127 + radius * math.sin(phi) * math.sin(theta)),\n                math.floor(127 + radius * math.cos(theta))]\n\n        def get_fractal():\n            return np.uint8([[get_color(p.t[j * grid_size + i, 0], p.t[j * grid_size + i, 1]) for i in range(grid_size)] for j in range(grid_size)])\n\n        def step(fractal, dt):\n            p.step(dt)\n            fractal.pixel_array = np.array(get_fractal())\n            fractal.change_to_rgba_array()\n\n        text1 = Tex(\"Now, lets see how every possible pendulum evolves together.\").move_to([0, -3.5, 0])\n        text2 = Tex(\"Every pixel represents the state of a unique pendulum\").move_to([0, -3.5, 0])\n        text3 = Tex(\"We can update every pendulum and see how the states change.\").move_to([0, -3.5, 0])\n        # One unit is 270 px\n        fractal = ImageMobject(get_fractal()).scale(270 / grid_size * 7 / 2).to_edge(UP * 0.25)\n        self.add(fractal)\n        self.add(text1)\n        self.wait(5)\n        self.play( Transform(text1, text2) )\n        self.wait(5)\n        self.play( Transform(text1, text3) )\n        self.wait(2)\n        fractal.add_updater(step)\n        self.wait(30)\n        fractal.remove_updater(step)\n        self.play(FadeOut(fractal), FadeOut(text1))\n        self.clear()\n        self.wait(3)\n\n\nparam= \"-v WARNING  --progress_bar None   -r  500,200 --fps=3 --disable_caching Physical2Pendulum\"\n# paramgif= \"-v WARNING  --progress_bar None --format=gif  -r  500,200  --disable_caching PhysicalNPendulum\"\n%manim $param","identifier":"nb-cell-1-f9b4f66a5a-code","enumerator":"2","html_id":"nb-cell-1-f9b4f66a5a-code","key":"DRl4pcSGry"},{"type":"output","id":"6fDFNNPJWKhNrkU194VDl","data":[{"output_type":"display_data","metadata":{},"data":{"text/html":{"content_type":"text/html","hash":"00df988168167789ae500dfd5aebc834","path":"/physicsmyst/build/00df988168167789ae500dfd5aebc834.html"},"text/plain":{"content":"<IPython.core.display.Video object>","content_type":"text/plain"}}}],"identifier":"nb-cell-1-f9b4f66a5a-output","html_id":"nb-cell-1-f9b4f66a5a-output","key":"Y2sDd1R8l0"}],"data":{"id":"nb-cell-1-f9b4f66a5a","type":"notebook-code"},"identifier":"nb-cell-1-f9b4f66a5a","label":"nb-cell-1-f9b4f66a5a","html_id":"nb-cell-1-f9b4f66a5a","key":"DuTfSQiKwd"}],"key":"NhqAo5x8TB"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"media-notebook","url":"/media-notebook","group":"Minimal Example"},"next":{"title":"wave","url":"/wave","group":"Minimal Example"}}},"domain":"http://localhost:3000"}